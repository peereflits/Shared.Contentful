using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Contentful.Core.Models;
using Contentful.Core.Models.Management;
using McMaster.Extensions.CommandLineUtils;

namespace Peereflits.Shared.Contentful.ModelsGenerator.Cli;

internal class ModelWriter : ClassGeneratorBase
{
    private readonly IConsole console;
    private readonly string outputDirectory;
    private readonly bool shouldOverWrite;
    private readonly string @namespace;
    private readonly bool isInternal;

    private readonly List<ContentType> contentTypes = [];

    public ModelWriter
    (
        IConsole console,
        string outputDirectory,
        bool shouldOverWrite,
        string @namespace,
        bool isInternal
    )
    {
        this.console = console;
        this.outputDirectory = outputDirectory;
        this.shouldOverWrite = shouldOverWrite;
        this.@namespace = @namespace;
        this.isInternal = isInternal;
    }

    public async Task WriteModels(IEnumerable<ContentType> contentfulTypes)
    {
        this.contentTypes.AddRange(contentfulTypes);

        foreach (var contentType in contentTypes)
        {
            var fileName = GetSafeFilename(FormatClassName(contentType.SystemProperties.Id));
            var path = Path.Combine(outputDirectory, $"{fileName}.g.cs");

            if (System.IO.File.Exists(path) && !shouldOverWrite)
            {
                console.ForegroundColor = ConsoleColor.Yellow;
                var msg = $"The file '{fileName}.g.cs' already exists. Do you want to overwrite it? [y/n]";
                console.WriteLine(msg);
                bool isYes = (await console.In.ReadLineAsync())?.ToLowerInvariant() == "y";
                console.ResetColor();

                if (!isYes)
                {
                    console.ForegroundColor = ConsoleColor.Red;
                    console.WriteLine($"Skipping {fileName}.g.cs");
                    console.ResetColor();
                    continue;
                }
            }

            console.WriteLine($"Generating file {fileName}.g.cs");
            await System.IO.File.WriteAllTextAsync(path, GenerateClass(contentType).ToString());
        }
    }

    private StringBuilder GenerateClass(ContentType contentType)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// ===================================================================== //");
        sb.AppendLine("// == This file is generated by the Contentful.ModelsGenerator.Cli    == //");
        sb.AppendLine("// ===================================================================== //");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Contentful.Core.Models;");
        sb.AppendLine();
        sb.AppendLine($"namespace {@namespace};");
        sb.AppendLine();
        sb.AppendLine("#pragma warning disable CS8669");

        //start class
        sb.AppendLine($"{(isInternal ? "internal" : "public")} partial record {FormatClassName(contentType.SystemProperties.Id)}");
        sb.AppendLine("{");
        sb.AppendLine($"    public const string ContentTypeId = \"{contentType.SystemProperties.Id}\";");
        sb.AppendLine("    public required SystemProperties Sys { get; set; }");

        foreach (var field in contentType.Fields)
        {
            var typeName = GetDataTypeForField(field);
            var propertyName = FirstLetterToUpperCase(field.Id);
            sb.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
        }

        sb.AppendLine("}");
        sb.AppendLine("#pragma warning restore CS8669");
        sb.AppendLine();
        //end class

        return sb;
    }

    private string GetSafeFilename(string filename)
        => string
            .Join("-", filename.Split(Path.GetInvalidFileNameChars()))
            .Replace(" ", string.Empty);

    private string GetDataTypeForField(Field field)
    {
#if DEBUG
        console.WriteLine($"Processing field {field.Id} of type {field.Type}");
#endif

        switch (field.Type)
        {
            case "RichText":
                return field.Required ? $"required {nameof(Document)}" : $"{nameof(Document)}?";
            case "Location":
                return field.Required ? $"required {nameof(Location)}" : $"{nameof(Location)}?";
            case "Symbol":
            case "Text":
                return field.Required ? "required string" : "string?";
            case "Integer":
                return field.Required ? "int" : "int?";
            case "Date":
                return field.Required ? "DateTime" : "DateTime?";
            case "Number":
                return field.Required ? "float" : "float?";
            case "Boolean":
                return field.Required ? "bool" : "bool?";
            case "Link":
                return (field.Required ? "required " : "") + GetDataTypeForLinkField(field) +
                       (field.Required ? "" : "?");
            case "Array":
                return (field.Required ? "required " : "") + GetDataTypeForListField(field);
            default:
                return field.Required ? "required object" : "object?";
        }
    }

    private string GetDataTypeForLinkField(Field field)
    {
        if (field.LinkType == nameof(Asset))
        {
            return nameof(Asset);
        }

        if (field.LinkType != "Entry")
        {
            return "object";
        }

        var validator = GetFieldContentTypeValidators(field).FirstOrDefault();

        return validator?.ContentTypeIds.Count == 1
            ? GetDataTypeForContentTypeId(validator.ContentTypeIds[0])
            : "object";
    }

    private static List<LinkContentTypeValidator> GetFieldContentTypeValidators(Field field) =>
        field.Validations.OfType<LinkContentTypeValidator>().ToList();

    private string GetDataTypeForContentTypeId(string contentTypeId)
    {
        var contentType = contentTypes.FirstOrDefault(c => c.SystemProperties.Id == contentTypeId);
        return contentType == null ? "object" : FormatClassName(contentType.SystemProperties.Id);
    }

    private string GetDataTypeForListField(Field field)
    {
        if (field.Items.LinkType == nameof(Asset))
        {
            return "List<Asset>";
        }

        if (field.Items.Type == "Symbol")
        {
            return "List<string>";
        }

        if (field.Items.LinkType != "Entry")
        {
            return "object";
        }

        var validators = GetFieldItemsContentTypeValidators(field);
        if (!validators.Any())
        {
            return "List<object>";
        }

        var contentTypeIds = validators.SelectMany(x => x.ContentTypeIds).ToList();

        return contentTypeIds.Count == 1
            ? $"List<{GetDataTypeForContentTypeId(contentTypeIds[0])}>"
            : "List<object>";
    }

    private static List<LinkContentTypeValidator> GetFieldItemsContentTypeValidators(Field field) =>
        field.Items?.Validations.OfType<LinkContentTypeValidator>().ToList() ?? [];
}