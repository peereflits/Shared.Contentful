using System.Text;
using System.Text.RegularExpressions;
using Contentful.Core.Models;
using Contentful.Core.Models.Management;
using McMaster.Extensions.CommandLineUtils;

namespace Peereflits.Shared.Contentful.ModelsGenerator.Cli
{
    internal class ModelWriter
    {
        private readonly IConsole console;
        private readonly string outputDirectory;
        private readonly bool shouldOverWrite;
        private readonly string @namespace;
        private readonly bool isInternal;

        private readonly List<ContentType> contentTypes = new();

        public ModelWriter
        (
            IConsole console,
            string outputDirectory,
            bool shouldOverWrite,
            string @namespace,
            bool isInternal
        )
        {
            this.console = console;
            this.outputDirectory = outputDirectory;
            this.shouldOverWrite = shouldOverWrite;
            this.@namespace = @namespace;
            this.isInternal = isInternal;
        }

        public async Task WriteModels(IEnumerable<ContentType> contentfulTypes)
        {
            this.contentTypes.AddRange(contentfulTypes);

            var dir = new DirectoryInfo(outputDirectory);

            foreach (var contentType in contentTypes)
            {
                var fileName = GetSafeFilename(FormatClassName(contentType.SystemProperties.Id));
                var file = new FileInfo(Path.Combine(dir.FullName, $"{fileName}.g.cs"));

                if (file.Exists && !shouldOverWrite)
                {
                    console.ForegroundColor = ConsoleColor.Yellow;
                    var msg = $"The file '{file.Name}' already exists. Do you want to overwrite it?";
                    bool isYes = Prompt.GetYesNo(msg, true);
                    console.ResetColor();

                    if (!isYes)
                    {
                        console.ForegroundColor = ConsoleColor.Red;
                        console.WriteLine($"Skipping {file.Name}");
                        console.ResetColor();
                        continue;
                    }
                }

                console.WriteLine($"Generating file {file.Name}");
                await using var sw = file.CreateText();
                await sw.WriteLineAsync(GenerateClass(contentType));
            }
        }

        private StringBuilder GenerateClass(ContentType contentType)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// ===================================================================== //");
            sb.AppendLine("// == This file is generated by the Contentful.ModelsGenerator.Cli    == //");
            sb.AppendLine("// ===================================================================== //");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Text;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Contentful.Core.Models;");
            sb.AppendLine();
            sb.AppendLine($"namespace {@namespace};");
            sb.AppendLine();
            sb.AppendLine("#pragma warning disable CS8669");

            //start class
            sb.AppendLine($"{(isInternal ? "internal" : "public")} partial record {FormatClassName(contentType.SystemProperties.Id)}");
            sb.AppendLine("{");
            sb.AppendLine($"    public const string ContentTypeId = \"{contentType.SystemProperties.Id}\";");
            sb.AppendLine("    public required SystemProperties Sys { get; set; }");

            foreach (var field in contentType.Fields)
            {
                var typeName = GetDataTypeForField(field);
                var propertyName = FirstLetterToUpperCase(field.Id);
                sb.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
            }

            sb.AppendLine("}");
            sb.AppendLine("#pragma warning restore CS8669");
            sb.AppendLine();
            //end class

            return sb;
        }

        private static string FormatClassName(string name) => FirstLetterToUpperCase(RemoveProhibitedCharacters(name));

        private static string FirstLetterToUpperCase(string word)
        {
            if (string.IsNullOrEmpty(word))
            {
                return word;
            }

            var a = word.ToCharArray();
            a[0] = char.ToUpper(a[0]);
            return new string(a);
        }

        private static string RemoveProhibitedCharacters(string word) =>
            Regex.Replace(word, "[^A-Za-z0-9_]", string.Empty);

        private string GetSafeFilename(string filename)
            => string
                .Join("-", filename.Split(Path.GetInvalidFileNameChars()))
                .Replace(" ", string.Empty);

        private string GetDataTypeForField(Field field)
        {
#if DEBUG
            console.WriteLine($"Processing field {field.Id} of type {field.Type}");
#endif

            switch (field.Type)
            {
                case "RichText":
                    return field.Required ? $"required {nameof(Document)}" : $"{nameof(Document)}?";
                case "Location":
                    return field.Required ? $"required {nameof(Location)}" : $"{nameof(Location)}?";
                case "Symbol":
                case "Text":
                    return field.Required ? "required string" : "string?";
                case "Integer":
                    return field.Required ? "int" : "int?";
                case "Date":
                    return field.Required ? "DateTime" : "DateTime?";
                case "Number":
                    return field.Required ? "float" : "float?";
                case "Boolean":
                    return field.Required ? "bool" : "bool?";
                case "Link":
                    return (field.Required ? "required " : "") + GetDataTypeForLinkField(field) +
                           (field.Required ? "" : "?");
                case "Array":
                    return (field.Required ? "required " : "") + GetDataTypeForListField(field);
                default:
                    return field.Required ? "required object" : "object?";
            }
        }

        private string GetDataTypeForLinkField(Field field)
        {
            if (field.LinkType == nameof(Asset))
            {
                return  nameof(Asset);
            }

            if (field.LinkType != "Entry")
            {
                return "object";
            }

            var validator = GetLinkContentTypeValidators(field).FirstOrDefault();

            return validator?.ContentTypeIds.Count == 1
                ? GetDataTypeForContentTypeId(validator.ContentTypeIds[0])
                : "object";
        }

        private string GetDataTypeForContentTypeId(string contentTypeId)
        {
            var contentType = contentTypes.FirstOrDefault(c => c.SystemProperties.Id == contentTypeId);
            return contentType == null ? "object" : FormatClassName(contentType.SystemProperties.Id);
        }

        private string GetDataTypeForListField(Field field)
        {
            if (field.Items.LinkType == nameof(Asset))
            {
                return "List<Asset>";
            }

            if (field.Items.Type == "Symbol")
            {
                return "List<string>";
            }

            if (field.Items.LinkType != "Entry")
            {
                return "object";
            }

            if (!GetListContentTypeValidators(field).Any())
            {
                return "List<object>";
            }

            var validator = GetListContentTypeValidators(field).FirstOrDefault();

            return validator?.ContentTypeIds.Any() ?? false
                ? $"List<{GetDataTypeForContentTypeId(validator.ContentTypeIds[0])}>"
                : "List<object>";
        }

        private static List<LinkContentTypeValidator> GetLinkContentTypeValidators(Field field) =>
            field.Validations == null
                ? []
                : field.Validations.OfType<LinkContentTypeValidator>().ToList();

        private static List<LinkContentTypeValidator> GetListContentTypeValidators(Field field) =>
            field.Items == null
                ? []
                : field.Items.Validations.OfType<LinkContentTypeValidator>().ToList();
    }
}