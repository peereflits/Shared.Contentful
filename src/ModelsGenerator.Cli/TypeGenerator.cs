using System.Collections.Generic;
using System.Linq;
using System.Text;
using Contentful.Core.Models;
using Contentful.Core.Models.Management;

namespace Peereflits.Shared.Contentful.ModelsGenerator.Cli;

internal interface IGenerateType
{
    string Generate(ContentType contentType);
}

internal class TypeGenerator : ClassGeneratorBase, IGenerateType
{
    private readonly string @namespace;
    private readonly bool isInternal;
    private readonly List<ContentType> contentTypes = [];

    public TypeGenerator
    (
        string @namespace,
        bool isInternal,
        IEnumerable<ContentType> contentfulTypes
    )
    {
        this.@namespace = @namespace;
        this.isInternal = isInternal;
        this.contentTypes.AddRange(contentfulTypes);
    }

    public string Generate(ContentType contentType)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// ===================================================================== //");
        sb.AppendLine("// == This file is generated by the Contentful.ModelsGenerator.Cli    == //");
        sb.AppendLine("// ===================================================================== //");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Contentful.Core.Models;");
        sb.AppendLine();
        sb.AppendLine($"namespace {@namespace};");
        sb.AppendLine();
        sb.AppendLine("#pragma warning disable CS8669");

        //start class
        sb.AppendLine($"{(isInternal ? "internal" : "public")} partial record {FormatClassName(contentType.SystemProperties.Id)}");
        sb.AppendLine("{");
        sb.AppendLine($"    public const string ContentTypeId = \"{contentType.SystemProperties.Id}\";");
        sb.AppendLine("    public required SystemProperties Sys { get; set; }");

        foreach (var field in contentType.Fields)
        {
            var typeName = GetDataTypeForField(field);
            var propertyName = FirstLetterToUpperCase(field.Id);
            sb.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
        }

        sb.AppendLine("}");
        sb.AppendLine("#pragma warning restore CS8669");
        sb.AppendLine();
        //end class

        return sb.ToString();
    }

    private string GetDataTypeForField(Field field)
    {
        switch (field.Type)
        {
            case "RichText":
                return field.Required ? $"required {nameof(Document)}" : $"{nameof(Document)}?";
            case "Location":
                return field.Required ? $"required {nameof(Location)}" : $"{nameof(Location)}?";
            case "Symbol":
            case "Text":
                return field.Required ? "required string" : "string?";
            case "Integer":
                return field.Required ? "int" : "int?";
            case "Date":
                return field.Required ? "DateTime" : "DateTime?";
            case "Number":
                return field.Required ? "float" : "float?";
            case "Boolean":
                return field.Required ? "bool" : "bool?";
            case "Link":
                return (field.Required ? "required " : "") + GetDataTypeForLinkField(field) +
                       (field.Required ? "" : "?");
            case "Array":
                return (field.Required ? "required " : "") + GetDataTypeForListField(field) +
                       (field.Required ? "" : "?");
            default:
                return field.Required ? "required object" : "object?";
        }
    }

    private string GetDataTypeForLinkField(Field field)
    {
        if (field.LinkType == nameof(Asset))
        {
            return nameof(Asset);
        }

        if (field.LinkType != "Entry")
        {
            return "object";
        }

        var validator = GetFieldContentTypeValidators(field).FirstOrDefault();

        return validator?.ContentTypeIds.Count == 1
            ? GetDataTypeForContentTypeId(validator.ContentTypeIds.Single())
            : "object";
    }

    private static List<LinkContentTypeValidator> GetFieldContentTypeValidators(Field field) =>
        field?.Validations?.OfType<LinkContentTypeValidator>()?.ToList() ?? [];

    private string GetDataTypeForContentTypeId(string contentTypeId)
    {
        var contentType = contentTypes.FirstOrDefault(c => c.SystemProperties.Id == contentTypeId);
        return contentType == null ? "object" : FormatClassName(contentTypeId);
    }

    private string GetDataTypeForListField(Field field)
    {
        if (field.Items.LinkType == nameof(Asset))
        {
            return "List<Asset>";
        }

        if (field.Items.LinkType != "Entry")
        {
            switch (field.Items.Type)
            {
                case "Symbol":
                    return "List<string>";
                default: // This should never happen
                    return "List<object>";
            }
        }

        var validators = GetFieldItemsContentTypeValidators(field);
        if (!validators.Any())
        {
            return "List<object>";
        }

        var contentTypeIds = validators.SelectMany(x => x.ContentTypeIds).ToList();

        return contentTypeIds.Count == 1
            ? $"List<{GetDataTypeForContentTypeId(contentTypeIds[0])}>"
            : "List<object>";
    }

    private static List<LinkContentTypeValidator> GetFieldItemsContentTypeValidators(Field field) =>
        field.Items?.Validations?.OfType<LinkContentTypeValidator>()?.ToList() ?? [];
}